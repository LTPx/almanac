generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String?
  dateOfBirth   DateTime?
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]
  walletAddress String?   @unique
  encryptedKey  String?

  // Educational relationships
  userCurriculumProgress UserCurriculumProgress[]
  testAttempts           TestAttempt[]
  finalTestAttempts      FinalTestAttempt[]
  streaks                UserStreak[]
  userUnitProgress       UserUnitProgress[]

  //Blockchain
  nfts EducationalNFT[]

  // GAMIFICATION 
  hearts                    Int      @default(5)
  totalExperiencePoints     Int      @default(0)
  zapTokens                 Int      @default(0)
  lastHeartReset            DateTime @default(now())
  totalCurriculumsCompleted Int      @default(0)

  // GAMIFICATION - relationships
  userCurriculumTokens UserCurriculumToken[]
  heartTransactions    HeartTransaction[]
  zapTransactions      ZapTransaction[]

  // Subscriptions
  subscriptionStatus            SubscriptionStatus @default(FREE)
  subscriptionCurrentPeriodEnd  DateTime?
  subscriptionTrialEnd          DateTime?
  subscriptionCancelAtPeriodEnd Boolean            @default(false)
  subscription                  Subscription?

  // Problem reports
  problemReports ProblemReport[]

  // Ads tracking
  adViews  AdView[]
  adClicks AdClick[]

  // Almanac Tutor
  tutorSessions TutorSession[]

  // Language preference
  languagePreference String? // (ISO 639-1: es, en, fr, etc.)

  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Curriculum {
  id               String          @id @default(cuid())
  title            String
  audienceAgeRange String?
  difficulty       DifficultyLevel
  units            Unit[]
  metadata         Json?
  isActive         Boolean         @default(true)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  // GAMIFICATION 
  userCurriculumTokens UserCurriculumToken[]
  zapTransactions      ZapTransaction[]

  // Progress
  userCurriculumProgress UserCurriculumProgress[]

  educationalNFTs EducationalNFT[]

  // Final Test
  finalTest FinalTest?

  // Ads
  ads Ad[]
}

model LearningObjective {
  id       Int     @id @default(autoincrement())
  text     String
  unit     Unit?   @relation(fields: [unitId], references: [id])
  unitId   Int?
  lesson   Lesson? @relation(fields: [lessonId], references: [id])
  lessonId Int?
}

model Fact {
  id        Int        @id @default(autoincrement())
  lesson    Lesson     @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  lessonId  Int
  text      String
  core      Boolean    @default(false)
  citations Citation[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model Citation {
  id         Int       @id @default(autoincrement())
  title      String
  authors    String?
  year       Int?
  fact       Fact?     @relation(fields: [factId], references: [id])
  factId     Int?
  question   Question? @relation(fields: [questionId], references: [id])
  questionId Int?
}

model Unit {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  lessons     Lesson[]
  order       Int
  position    Int?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  mandatory        Boolean @default(true)
  experiencePoints Int     @default(25)

  // test
  questions Question[]

  // Progress
  userUnitProgress UserUnitProgress[]

  //Education - relationships
  curriculum         Curriculum?         @relation(fields: [curriculumId], references: [id])
  curriculumId       String?
  learningObjectives LearningObjective[]
  testAttempt        TestAttempt[]

  @@map("unit")
}

model Lesson {
  id                 Int                 @id @default(autoincrement())
  name               String
  description        String?
  unit               Unit                @relation(fields: [unitId], references: [id], onDelete: Cascade)
  unitId             Int
  position           Int?
  isActive           Boolean             @default(true)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  learningObjectives LearningObjective[]
  facts              Fact[]
  tutorSessions      TutorSession[]

  @@map("lesson")
}

model Question {
  id        Int          @id @default(autoincrement())
  unit      Unit         @relation(fields: [unitId], references: [id], onDelete: Cascade)
  unitId    Int
  type      QuestionType
  title     String
  order     Int
  isActive  Boolean      @default(true)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  content   Json

  answers            Answer[]
  testAnswers        TestAnswer[]
  citations          Citation[]
  problemReports     ProblemReport[]
  finalTestQuestions FinalTestQuestion[]
  finalTestAnswers   FinalTestAnswer[]

  @@map("question")
}

model Answer {
  id         Int      @id @default(autoincrement())
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId Int
  text       String // Texto de la respuesta
  isCorrect  Boolean // Si es la respuesta correcta
  order      Int // Orden de la opción
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("answer")
}

model UserCurriculumProgress {
  id               Int        @id @default(autoincrement())
  user             User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String
  curriculum       Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)
  curriculumId     String
  isCompleted      Boolean    @default(false)
  experiencePoints Int        @default(0)
  completedAt      DateTime?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  @@unique([userId, curriculumId])
  @@map("user_curriculum_progress")
}

model UserUnitProgress {
  id               Int       @id @default(autoincrement())
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String
  unit             Unit      @relation(fields: [unitId], references: [id], onDelete: Cascade)
  unitId           Int
  experiencePoints Int       @default(0)
  completedAt      DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@unique([userId, unitId])
  @@map("user_unit_progress")
}

model TestAttempt {
  id             Int          @id @default(autoincrement())
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  unit           Unit         @relation(fields: [unitId], references: [id])
  unitId         Int
  score          Float
  totalQuestions Int
  correctAnswers Int
  isCompleted    Boolean      @default(false)
  startedAt      DateTime     @default(now())
  completedAt    DateTime?
  questionOrder  Json?
  answers        TestAnswer[]

  heartTransactions HeartTransaction[]

  @@map("test_attempt")
}

model TestAnswer {
  id            Int         @id @default(autoincrement())
  testAttempt   TestAttempt @relation(fields: [testAttemptId], references: [id], onDelete: Cascade)
  testAttemptId Int
  question      Question    @relation(fields: [questionId], references: [id])
  questionId    Int
  userAnswer    String // Respuesta del usuario (puede ser texto, JSON, etc.)
  isCorrect     Boolean
  timeSpent     Int? // Tiempo en segundos
  createdAt     DateTime    @default(now())

  @@map("test_answer")
}

model FinalTest {
  id             Int        @id @default(autoincrement())
  curriculum     Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)
  curriculumId   String     @unique // Un test final por curriculum
  title          String?
  description    String?
  passingScore   Float      @default(70) // Porcentaje mínimo para aprobar
  totalQuestions Int        @default(10) // Número de preguntas en el test
  isActive       Boolean    @default(true)
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  // Relaciones
  questions FinalTestQuestion[]
  attempts  FinalTestAttempt[]

  @@map("final_test")
}

model FinalTestQuestion {
  id          Int       @id @default(autoincrement())
  finalTest   FinalTest @relation(fields: [finalTestId], references: [id], onDelete: Cascade)
  finalTestId Int
  question    Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId  Int
  order       Int // Orden de la pregunta en el test final
  createdAt   DateTime  @default(now())

  @@unique([finalTestId, questionId]) // Una pregunta solo puede estar una vez en el test
  @@map("final_test_question")
}

model FinalTestAttempt {
  id             Int               @id @default(autoincrement())
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  finalTest      FinalTest         @relation(fields: [finalTestId], references: [id], onDelete: Cascade)
  finalTestId    Int
  score          Float
  totalQuestions Int
  correctAnswers Int
  isPassed       Boolean           @default(false) // Si aprobó el test final
  isCompleted    Boolean           @default(false)
  startedAt      DateTime          @default(now())
  completedAt    DateTime?
  questionOrder  Json? // Orden aleatorio de preguntas si aplica
  answers        FinalTestAnswer[]

  heartTransactions HeartTransaction[]

  @@map("final_test_attempt")
}

model FinalTestAnswer {
  id                 Int              @id @default(autoincrement())
  finalTestAttempt   FinalTestAttempt @relation(fields: [finalTestAttemptId], references: [id], onDelete: Cascade)
  finalTestAttemptId Int
  question           Question         @relation(fields: [questionId], references: [id])
  questionId         Int
  userAnswer         String // Respuesta del usuario
  isCorrect          Boolean
  timeSpent          Int? // Tiempo en segundos
  createdAt          DateTime         @default(now())

  @@map("final_test_answer")
}

model ProblemReport {
  id          Int                 @id @default(autoincrement())
  question    Question            @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId  Int
  user        User?               @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId      String?
  reason      String
  description String?
  status      ProblemReportStatus @default(PENDING)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@map("problem_report")
}

model UserStreak {
  id            Int      @id @default(autoincrement())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String   @unique
  currentStreak Int      @default(0)
  longestStreak Int      @default(0)
  lastActivity  DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("user_streak")
}

// GAMIFICATION
model UserCurriculumToken {
  id           Int        @id @default(autoincrement())
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  curriculum   Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)
  curriculumId String
  quantity     Int        @default(1)
  earnedAt     DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([userId, curriculumId])
  @@map("user_curriculum_token")
}

model HeartTransaction {
  id                        Int                  @id @default(autoincrement())
  user                      User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                    String
  type                      HeartTransactionType
  amount                    Int // Amount + or -
  reason                    String?
  relatedTestAttemptId      Int?
  relatedTestAttempt        TestAttempt?         @relation(fields: [relatedTestAttemptId], references: [id])
  relatedFinalTestAttemptId Int?
  relatedFinalTestAttempt   FinalTestAttempt?    @relation(fields: [relatedFinalTestAttemptId], references: [id])
  createdAt                 DateTime             @default(now())

  @@map("heart_transaction")
}

model ZapTransaction {
  id                  Int                @id @default(autoincrement())
  user                User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId              String
  type                ZapTransactionType
  amount              Int
  reason              String?
  relatedCurriculumId String?
  relatedCurriculum   Curriculum?        @relation(fields: [relatedCurriculumId], references: [id])
  createdAt           DateTime           @default(now())

  @@map("zap_transaction")
}

//BLOCKCHAIN
model EducationalNFT {
  id                   String     @id @default(cuid())
  tokenId              String
  userId               String
  contractAddress      String
  transactionHash      String?
  metadataUri          String
  mintedAt             DateTime   @default(now())
  user                 User       @relation(fields: [userId], references: [id])
  curriculum           Curriculum @relation(fields: [curriculumId], references: [id])
  curriculumId         String
  curriculumStartedAt  DateTime?
  curriculumFinishedAt DateTime?

  // relationships
  nftAsset     NFTAsset?      @relation(fields: [nftAssetId], references: [id])
  nftAssetId   Int?           @unique
  collection   NFTCollection? @relation(fields: [collectionId], references: [id])
  collectionId String?

  @@map("educational_nft")
}

model NFTAsset {
  id          Int       @id @default(autoincrement())
  name        String    @default("")
  imageUrl    String
  rarity      NFTRarity
  isUsed      Boolean   @default(false)
  metadataUri String?
  createdAt   DateTime  @default(now())
  usedAt      DateTime?

  // relationship
  educationalNFT EducationalNFT?

  // relationship to collection
  collection   NFTCollection? @relation(fields: [collectionId], references: [id])
  collectionId String?

  @@map("nft_asset")
}

model NFTCollection {
  id              String   @id @default(cuid())
  name            String
  symbol          String
  description     String?
  contractAddress String   @unique
  chainId         Int      @default(80002) // Polygon testnet Amoy
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // relationships
  educationalNFTs EducationalNFT[]
  nftAssets       NFTAsset[]

  @@map("nft_collection")
}

model Subscription {
  id       String          @id @default(cuid())
  user     User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   String          @unique
  platform PaymentPlatform

  // Platform-specific IDs (solo uno será usado dependiendo de platform)
  // STRIPE
  stripeSubscriptionId String? @unique
  stripeCustomerId     String?
  stripePriceId        String?
  stripeProductId      String?

  // GOOGLE PLAY BILLING
  googlePlaySubscriptionId String? @unique // purchaseToken de Google
  googlePlayProductId      String? // SKU del producto
  googlePlayOrderId        String? // orderId único de Google
  googlePlayPackageName    String? // com.tuapp.nombre

  // APPLE
  appleTransactionId         String? @unique
  appleOriginalTransactionId String?
  appleProductId             String?

  // Status (universal para todas las plataformas)
  status SubscriptionStatus @default(TRIALING)

  // Dates (universales)
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  trialStart         DateTime?
  trialEnd           DateTime?
  canceledAt         DateTime?
  cancelAtPeriodEnd  Boolean   @default(false)
  endedAt            DateTime?

  // Metadata flexible (puede contener info específica de cada plataforma)
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stripeSubscriptionId])
  @@index([googlePlaySubscriptionId])
  @@index([appleTransactionId])
  @@index([platform, status])
  @@map("subscription")
}

model PaymentTransaction {
  id            String          @id @default(cuid())
  userId        String
  platform      PaymentPlatform
  transactionId String // ID de la transacción en la plataforma
  type          TransactionType
  amount        Int? // En centavos (ej: 500 = $5.00)
  currency      String? // USD, EUR, etc
  status        String // succeeded, failed, pending, refunded
  metadata      Json? // Info adicional específica de la plataforma
  createdAt     DateTime        @default(now())

  @@index([userId])
  @@index([platform])
  @@index([transactionId])
  @@map("payment_transaction")
}

//ENUMS
enum ZapTransactionType {
  UNIT_COMPLETED // Ganó ZAPs por completar unidad
  HEART_PURCHASE // Gastó ZAPs en comprar corazón
  LESSON_COMPLETED // Ganó ZAPs por completar lección
  DAILY_BONUS // Bonificación diaria
  ADMIN_ADJUSTMENT // Ajuste manual por admin
  TOKEN_MINTED // Mintear un token
  AD_REWARD // Recompensa por ver anuncio

  @@map("zap_transaction_type")
}

enum HeartTransactionType {
  DAILY_RESET // Reseteo diario automático
  TEST_FAILED // Perdió corazón por fallar test
  PURCHASED // Compró corazón con ZAPs
  BONUS // Bonificación especial
  ADMIN_ADJUSTMENT // Ajuste manual por admin

  @@map("heart_transaction_type")
}

enum QuestionType {
  MULTIPLE_CHOICE // Pregunta de opción múltiple
  FILL_IN_BLANK // Completar espacios en blanco
  ORDER_WORDS // Ordenar palabras/oraciones
  TRUE_FALSE // Verdadero/Falso
  MATCHING // Emparejar elementos
  DRAG_DROP // Arrastrar y soltar

  @@map("question_type")
}

enum NFTRarity {
  NORMAL
  RARE
  EPIC
  UNIQUE

  @@map("nft_rarity")
}

enum DifficultyLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED

  @@map("difficulty_level")
}

enum PaymentPlatform {
  STRIPE
  GOOGLE_PLAY
  APPLE

  @@map("payment_platform")
}

enum SubscriptionStatus {
  FREE
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  INCOMPLETE // Incompleta (Stripe)
  INCOMPLETE_EXPIRED // Incompleta y expirada (Stripe)
  PAUSED
  PENDING // Pendiente de confirmación (Google/Apple)
  ON_HOLD // En espera (Google Play)
  EXPIRED // Expirada

  @@map("subscription_status")
}

enum TransactionType {
  SUBSCRIPTION_START
  SUBSCRIPTION_RENEWAL
  SUBSCRIPTION_CANCEL
  REFUND
  TRIAL_CONVERSION

  @@map("transaction_type")
}

enum ProblemReportStatus {
  PENDING
  IN_REVIEW
  RESOLVED
  DISMISSED

  @@map("problem_report_status")
}

// ADS SYSTEM
model Ad {
  id          Int      @id @default(autoincrement())
  title       String
  description String?
  imageUrl    String // URL de la imagen del ad
  targetUrl   String // URL a la que redirige cuando se hace click
  isActive    Boolean  @default(true)
  position    Int      @default(0) // Orden de aparición si hay múltiples ads
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Tracking
  views  AdView[]
  clicks AdClick[]

  curriculum   Curriculum @relation(fields: [curriculumId], references: [id])
  curriculumId String

  @@map("ad")
}

model AdView {
  id       Int      @id @default(autoincrement())
  ad       Ad       @relation(fields: [adId], references: [id], onDelete: Cascade)
  adId     Int
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   String
  viewedAt DateTime @default(now())

  @@map("ad_view")
}

model AdClick {
  id        Int      @id @default(autoincrement())
  ad        Ad       @relation(fields: [adId], references: [id], onDelete: Cascade)
  adId      Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  clickedAt DateTime @default(now())

  @@map("ad_click")
}

// ALMANAC TUTOR SYSTEM
model TutorSession {
  id         String    @id @default(cuid())
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  lesson     Lesson?   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  lessonId   Int?
  messages   Json // Historial completo de mensajes
  startedAt  DateTime  @default(now())
  lastActive DateTime  @default(now())
  endedAt    DateTime?

  // Métricas de la sesión
  messageCount  Int      @default(0)
  userMessages  Int      @default(0)
  tutorMessages Int      @default(0)
  wasHelpful    Boolean? // Rating del usuario (opcional)

  @@index([userId, startedAt])
  @@index([lessonId])
  @@map("tutor_session")
}

model TutorConfig {
  id                 String   @id @default("default") // Solo una fila
  routerInstructions String
  tutorInstructions  String
  masterCatalog      Json // Array de los 11 tracks del Master Catalog
  routerModel        String   @default("gemini-2.0-flash") // Modelo para el router
  routerTemperature  Float    @default(0.1) // Temperatura del router (0.0-1.0)
  updatedAt          DateTime @updatedAt
  createdAt          DateTime @default(now())

  @@map("tutor_config")
}
