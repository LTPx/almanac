generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String?
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]
  walletAddress String?   @unique
  encryptedKey  String?

  // Educational relationships
  userCurriculumProgress UserCurriculumProgress[]
  testAttempts           TestAttempt[]
  streaks                UserStreak[]
  userUnitProgress       UserUnitProgress[]

  //Blockchain
  nfts EducationalNFT[]

  // GAMIFICATION 
  hearts                    Int      @default(5)
  totalExperiencePoints     Int      @default(0)
  zapTokens                 Int      @default(0)
  lastHeartReset            DateTime @default(now())
  totalCurriculumsCompleted Int      @default(0)

  // GAMIFICATION - relationships
  userCurriculumTokens UserCurriculumToken[]
  heartTransactions    HeartTransaction[]
  zapTransactions      ZapTransaction[]

  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Curriculum {
  id               String          @id @default(cuid())
  title            String
  audienceAgeRange String?
  difficulty       DifficultyLevel
  units            Unit[]
  metadata         Json?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  // GAMIFICATION 
  userCurriculumTokens UserCurriculumToken[]
  zapTransactions      ZapTransaction[]

  // Progress
  userCurriculumProgress UserCurriculumProgress[]

  educationalNFTs EducationalNFT[]
}

model LearningObjective {
  id       Int     @id @default(autoincrement())
  text     String
  unit     Unit?   @relation(fields: [unitId], references: [id])
  unitId   Int?
  lesson   Lesson? @relation(fields: [lessonId], references: [id])
  lessonId Int?
}

model Fact {
  id        Int        @id @default(autoincrement())
  lesson    Lesson     @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  lessonId  Int
  text      String
  core      Boolean    @default(false)
  citations Citation[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model Citation {
  id         Int       @id @default(autoincrement())
  title      String
  authors    String?
  year       Int?
  fact       Fact?     @relation(fields: [factId], references: [id])
  factId     Int?
  question   Question? @relation(fields: [questionId], references: [id])
  questionId Int?
}

model Unit {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  lessons     Lesson[]
  order       Int
  position    Int?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  mandatory        Boolean @default(true)
  experiencePoints Int     @default(25)

  // test
  questions Question[]

  // Progress
  userUnitProgress UserUnitProgress[]

  //Education - relationships
  curriculum         Curriculum?         @relation(fields: [curriculumId], references: [id])
  curriculumId       String?
  learningObjectives LearningObjective[]
  testAttempt        TestAttempt[]

  @@map("unit")
}

model Lesson {
  id                 Int                 @id @default(autoincrement())
  name               String
  description        String?
  unit               Unit                @relation(fields: [unitId], references: [id], onDelete: Cascade)
  unitId             Int
  position           Int?
  isActive           Boolean             @default(true)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  learningObjectives LearningObjective[]
  facts              Fact[]

  @@map("lesson")
}

model Question {
  id        Int          @id @default(autoincrement())
  unit      Unit         @relation(fields: [unitId], references: [id], onDelete: Cascade)
  unitId    Int
  type      QuestionType
  title     String
  order     Int
  isActive  Boolean      @default(true)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  content   Json

  answers     Answer[]
  testAnswers TestAnswer[]
  citations   Citation[]

  @@map("question")
}

model Answer {
  id         Int      @id @default(autoincrement())
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionId Int
  text       String // Texto de la respuesta
  isCorrect  Boolean // Si es la respuesta correcta
  order      Int // Orden de la opción
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("answer")
}

model UserCurriculumProgress {
  id               Int        @id @default(autoincrement())
  user             User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String
  curriculum       Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)
  curriculumId     String
  isCompleted      Boolean    @default(false)
  experiencePoints Int        @default(0)
  completedAt      DateTime?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  @@unique([userId, curriculumId])
  @@map("user_curriculum_progress")
}

model UserUnitProgress {
  id               Int       @id @default(autoincrement())
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String
  unit             Unit      @relation(fields: [unitId], references: [id], onDelete: Cascade)
  unitId           Int
  experiencePoints Int       @default(0)
  completedAt      DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@unique([userId, unitId])
  @@map("user_unit_progress")
}

model TestAttempt {
  id             Int          @id @default(autoincrement())
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  unit           Unit         @relation(fields: [unitId], references: [id])
  unitId         Int
  score          Float
  totalQuestions Int
  correctAnswers Int
  isCompleted    Boolean      @default(false)
  startedAt      DateTime     @default(now())
  completedAt    DateTime?
  answers        TestAnswer[]

  heartTransactions HeartTransaction[]

  @@map("test_attempt")
}

model TestAnswer {
  id            Int         @id @default(autoincrement())
  testAttempt   TestAttempt @relation(fields: [testAttemptId], references: [id], onDelete: Cascade)
  testAttemptId Int
  question      Question    @relation(fields: [questionId], references: [id])
  questionId    Int
  userAnswer    String // Respuesta del usuario (puede ser texto, JSON, etc.)
  isCorrect     Boolean
  timeSpent     Int? // Tiempo en segundos
  createdAt     DateTime    @default(now())

  @@map("test_answer")
}

model UserStreak {
  id            Int      @id @default(autoincrement())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String   @unique
  currentStreak Int      @default(0)
  longestStreak Int      @default(0)
  lastActivity  DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("user_streak")
}

// GAMIFICATION
model UserCurriculumToken {
  id           Int        @id @default(autoincrement())
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  curriculum   Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)
  curriculumId String
  quantity     Int        @default(1)
  earnedAt     DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([userId, curriculumId])
  @@map("user_curriculum_token")
}

model HeartTransaction {
  id                   Int                  @id @default(autoincrement())
  user                 User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String
  type                 HeartTransactionType
  amount               Int // Amount + or -
  reason               String?
  relatedTestAttemptId Int?
  relatedTestAttempt   TestAttempt?         @relation(fields: [relatedTestAttemptId], references: [id])
  createdAt            DateTime             @default(now())

  @@map("heart_transaction")
}

model ZapTransaction {
  id                  Int                @id @default(autoincrement())
  user                User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId              String
  type                ZapTransactionType
  amount              Int
  reason              String?
  relatedCurriculumId String?
  relatedCurriculum   Curriculum?        @relation(fields: [relatedCurriculumId], references: [id])
  createdAt           DateTime           @default(now())

  @@map("zap_transaction")
}

//BLOCKCHAIN
model EducationalNFT {
  id              String     @id @default(cuid())
  tokenId         String
  userId          String
  contractAddress String
  transactionHash String?
  metadataUri     String
  mintedAt        DateTime   @default(now())
  user            User       @relation(fields: [userId], references: [id])
  curriculum      Curriculum @relation(fields: [curriculumId], references: [id])
  curriculumId    String
  nftAsset        NFTAsset?  @relation(fields: [nftAssetId], references: [id])
  nftAssetId      Int?       @unique

  @@map("educational_nft")
}

model NFTAsset {
  id             Int             @id @default(autoincrement())
  name           String          @default("")
  imageUrl       String
  rarity         NFTRarity
  isUsed         Boolean         @default(false)
  metadataUri    String?
  createdAt      DateTime        @default(now())
  usedAt         DateTime?
  educationalNFT EducationalNFT?

  @@map("nft_asset")
}

//ENUMS
enum ZapTransactionType {
  UNIT_COMPLETED // Ganó ZAPs por completar unidad
  HEART_PURCHASE // Gastó ZAPs en comprar corazón
  LESSON_COMPLETED // Ganó ZAPs por completar lección
  DAILY_BONUS // Bonificación diaria
  ADMIN_ADJUSTMENT // Ajuste manual por admin
  TOKEN_MINTED // Mintear un token

  @@map("zap_transaction_type")
}

enum HeartTransactionType {
  DAILY_RESET // Reseteo diario automático
  TEST_FAILED // Perdió corazón por fallar test
  PURCHASED // Compró corazón con ZAPs
  BONUS // Bonificación especial
  ADMIN_ADJUSTMENT // Ajuste manual por admin

  @@map("heart_transaction_type")
}

enum QuestionType {
  MULTIPLE_CHOICE // Pregunta de opción múltiple
  FILL_IN_BLANK // Completar espacios en blanco
  ORDER_WORDS // Ordenar palabras/oraciones
  TRUE_FALSE // Verdadero/Falso
  MATCHING // Emparejar elementos
  DRAG_DROP // Arrastrar y soltar

  @@map("question_type")
}

enum NFTRarity {
  NORMAL
  RARE
  EPIC
  UNIQUE

  @@map("nft_rarity")
}

enum DifficultyLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED

  @@map("difficulty_level")
}
